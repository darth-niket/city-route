Report by team members: 1. Akshay Venkatesh Murthy (akmurthy)
                        2. Nikhil Mahadevaswamy (nmahade)
                        3. Niket Nagaraj Malihalli (nmalihal)

ALL THE WORK FOR THIS ASSIGNMENT IS SOLELY OURS

--------------------------------------------------------------------------------------------------------------------------
PART 1
--------------------------------------------------------------------------------------------------------------------------
Problem Statement:
We have been given a 5x5 grid consisting of numbers 1-25 that are not in the right order. 
Our solution should aim at restoring the normal configuration of the board by performing a set legal moves which are Inner ring counter clock movement, Inner ring counter clock wise movement, Outer ring counter clock movement, Outer ring clock wise movement.
The solution should be reached in minimum number of moves.


Approach:
We employ A* search to implement a solution for this problem.

The state space for this problem is : 25
Heuristic function h(s) = Sum of Manhattan distance between current position and goal position for all numbers in the grid
Cost incurred to move to next state g(s) = Number of rotations or wraps done so far.
Cost = Sum of h(s) and g(s)


We start with an initial state and do a set of operations mentioned below:
1. Right wrap (on all five rows)
2. Left wrap (on all five rows)
3. Up shift wrap (on all five colomns)
4. Down shift wrap (on all five colomns)
5. Inner ring clockwise rotation
6. Outer ring clockwise rotation
7. Inner ring counter cloclwise rotation
8. Outer ring counter clockwise rotation

We calculate the cost incurred by executing each of the above moves mentioned and append them to a list of successors. These successors are appended to a fringe. On popping from the fring the successor with the least cost incurred is obtained and we check whether this is a goal state. If this is not a goal state we proceed to explore successors of this current successor. Cost is calculated for each state and appended to the fringe and each time a successor with the least cost is explored. We continue this process until we reach the goal state.


We also tried heuristics such as permutation inversion and number of tiles misplaced. The problem with these heuristics was that it took a long time to calculate and the cost values in the fringe were floating around the same ranges and not decreasing. Thus decided to stick with manhattan distance as a heuristic and proceeded to solve the problem.

Problems Faced:
While calculating the manhattan distance we noticed that this heuristic was overfitting and thus resulting in longer times to arrive at the solution. To underestimate the heuristic we have dived the sum of manhattan distances by the number of tiles that are moved for each of the operations. Thus we were able obtain the solution in reasonable time.


Questions from the assignment:
1.In this problem, what is the branching factor of the search tree?

Branching factor is the number of successors generated by each node. Which in this case is 25

2.If  the  solution  can  be  reached  in  7  moves,  about  how  many  states  would  we  need  to  explore  before  we found it if we used BFS instead of A* search?  A rough answer is fine.

--> Branching factor is the number of successors generated at each node. For each state we are generating 25 successors. 
    We would need to explore 25^28 states in the worst case to arrive at the solution



-------------------------------------------------------------------------------------------------------------------------
PART 2
-------------------------------------------------------------------------------------------------------------------------

Abstraction:

1. Set of states S
2. Initial State S0 which is the source location.
3. A successor function which returns the nearest possible locations from the source location.
4. Goal state which is our destintion location.
5. A cost function that estimates how expensive a given set of moves is ( which we can get it from road-segment data)
6. A heuristic function that estimates how promising a given state is. Here cost is return based on segments, distance , time or delivery.


Approach:

Based on the given cost function given by the user, we call one of the functons,i.e., optimum_distance, optimum_segments, optimum_delivery_time, optimum_time. In these functions, we use fringe to store our states which has all the data required for that particular state. At first we would sort the fringe data using heapq and then pop the elements one by one based on the priority. The Priority is called based on the cost function which is passed. For example, to find the optimum distance to reach the destination, first we would fetch the data from road_segments file and filter the  data based on initial source, then from this point we would get all its nearest destnination. To make the next move, We have H(s) using the haversine formula to get the distance using the latitude and longitues and the priority will be set for that state and pushed into fringe data-structure. This process repeates untill we reach the destination. Once the destination is reached, we would come out of the loop by skipping the remaining steps as we would have already got the optimized solution.

Challenges:

1. For some location, there was no latitute and longitute values which caused error in the program and was also yielding wrong soltuion, when checked with 0 values for the same. Then through inscribe discussion, we got an idea to make H(s) as Zero for those cases.
2. One duplicate record was present in city-Gps.txt which caused issuing in many test cases and It took losts of time to find the root cause and finally duplicate was removed and error was fixed.
3. Writing priority for each cost functions was also a challenge as our calculated priority value was failing for few test cases intially.
4. Directly adding the haversine distance as an priority value was not yeidling the solution as it was masking the g(s) function value. So we had to reduce its value to get the required solution.
5. Reading Data using pandas and avoiding index was an issue 




------------------------------------------------------------------------------------------------------------------------- 
PART 3
-------------------------------------------------------------------------------------------------------------------------
#Problem Statement:

We have been given set of survey inputs by various members of the course with their preferences for team members.
The time taken by the instructor to evaluate each time with additional overhead time once the survey is done and teams 
are formed is directly dependent on how much we try to form combinations of teams which almost or completely is in compliance/agreement
with their given preferences. Our goal is to form the best possible team formations a.k.a formations which reduces the overhead time
on the instructor's evaluation schedule. 

*Input reading*: Inputs are in the form as given in the problem with delimiters, we have parsed the file and read the inputs 
in form dictionary, which keys in the user id and maps its value to ([Preferred],[Not_preferred]), i.e
each user ID is put into the dictionary and its value consists of lists indicating the user's preferred members and 
non-preferred members, this also helps us in getting team size by simply calculating length of Preferred than maintaining another
attribute.

#Approach to the solution:

We employ a method of searching or probably can be called approaching towards best cost, here cost indicating the best time (least time) 
incurred by the instructor which is the total cost calculated based on given conditions, if the team is not formed w.r.t user preferences.
The main idea is to start from the state where each member is a team on its own and converge towards forming group sizes of 2,3.
At each step(state), we calculate cost incurred if that was the final team formed. We employ a fringe,used as a heapq lib data structure to keep a 
list of teams formed in the process. We define the following for this problem:
State space: All the team formations possible
Cost incurred to get a new state - combinations formed out of current state
cost = time calculated from the given conditions from the state(team formation)

The solution is best found by forming team formations by using combinations library of itertools which 
provides combinations of team members of particular size, in our case , we have formed combinations of 2.
We start with initial state and then get the cost stored in fringe and then use the same state, to achieve combinations of 2
performed on each element of the start state, the idea here is to form combinations sequentially and exhaustively
to obtain all combinations involving every member. With each team formation of 2 in each list added into the successor with a
third member added for formed group and we calculate cost and push it into the fringe. At each step, fringe is popped out and
examined the cost and if its lower than previous cost formed.

Algo:
Repeat: Fringe until empty:
        1-> pop out lowest cost element from the fringe
        2-> form groups and then yield the result
        3-> pass the current formation to generate new formations which calculates cost
        4-> if visited , then dont add to successor
        4-> go to step 1 and yield results in search of best cost result.

*Challenges faced*

Several challenges faced were due to formation of combinations and proper usage of library module
for the same. Calculation of costs according to given conditions and making it part of the fringe element
and popping out based on that was a learning from part 1 problem. Forming random combinations in search of
best possible output instead of brute force method of trying to form a team helped us to think 
problems with a AI aptitude
